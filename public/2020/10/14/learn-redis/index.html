<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis学习笔记 | Amzpiper</title><meta name="keywords" content="redis"><meta name="author" content="Amzpiper"><meta name="copyright" content="Amzpiper"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记">
<meta property="og:url" content="https://github.com/amzpiper/2020/10/14/learn-redis/index.html">
<meta property="og:site_name" content="Amzpiper">
<meta property="og:description" content="Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/amzpiper/2020/10/14/learn-redis/Untitled.png">
<meta property="article:published_time" content="2020-10-14T04:00:41.000Z">
<meta property="article:modified_time" content="2021-12-06T03:24:49.120Z">
<meta property="article:author" content="Amzpiper">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/amzpiper/2020/10/14/learn-redis/Untitled.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/amzpiper/2020/10/14/learn-redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"817TG72HTO","apiKey":"95b2a21f4cdb2875f04e2f8043cd9b9f","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-06 11:24:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://butterfly.js.org/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2020/10/14/learn-redis/Untitled.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Amzpiper</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-14T04:00:41.000Z" title="发表于 2020-10-14 12:00:41">2020-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-06T03:24:49.120Z" title="更新于 2021-12-06 11:24:49">2021-12-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="Untitled.png" alt="Untitled.png"></p>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
<h1 id="learn-redis"><a href="#learn-redis" class="headerlink" title="learn-redis"></a><strong>learn-redis</strong></h1><blockquote>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
</blockquote>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h1><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a><strong>1.基本命令</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ping                    # 测试联通：PONG</span><br><span class="line">set name value          # 设置KEY</span><br><span class="line">get name                # 获取KEY</span><br><span class="line">keys *                  # 查所有KEY</span><br><span class="line">select 0                # 切换数据库</span><br><span class="line">flushall                # 清空所有数据库</span><br><span class="line">flushdb                 # 清空所选数据库</span><br><span class="line">expire name time        # 设置KEY过期时间</span><br><span class="line">ttl name                # 查看剩余时间，-2为已过期</span><br><span class="line">exist name              # 判断KEY是否存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-五大基础类型"><a href="#2-五大基础类型" class="headerlink" title="2.五大基础类型"></a><strong>2.五大基础类型</strong></h2><h3 id="2-1-String类型"><a href="#2-1-String类型" class="headerlink" title="2.1.String类型"></a><strong>2.1.String类型</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">append                  # 追加数据，name不存在set</span><br><span class="line">strlen                  # 数据长度</span><br><span class="line"></span><br><span class="line">&lt;!-- 微信公众号浏览量,实现i++、i-- --&gt;</span><br><span class="line">set views 0</span><br><span class="line">incr views              # i++,持久化可以持久过去，暂时并不是要mysql</span><br><span class="line">decr views              # i--</span><br><span class="line"></span><br><span class="line">&lt;!-- 实现java步长 --&gt;</span><br><span class="line">incrby views 10         # 在基础上增加10</span><br><span class="line">decrby views 10         # 在基础上减少10</span><br><span class="line"></span><br><span class="line">&lt;!-- 截取字符串(左闭右开区间) --&gt;</span><br><span class="line">getrange name start end # 获得截取字符串</span><br><span class="line">getrange name 0 3       </span><br><span class="line">getrange name 0 -1      # 查看全部数据 </span><br><span class="line"></span><br><span class="line">&lt;!-- 替换数据 --&gt;</span><br><span class="line">setrange name 1 xx      # 0 -1，替换指定位置开始的字符串</span><br><span class="line"></span><br><span class="line">setex key seconds value # 如果存在,再设置过期时间</span><br><span class="line">setex key3 30 &quot;hello&quot;</span><br><span class="line">setnx key seconds value # 如果不存在,创建设置过期时间(分布式锁常常用)，如果已存在创建失败</span><br><span class="line">setnx name &quot;mongoDB&quot;    # 不存在再设置值，1成功，0失败</span><br><span class="line">mset k1 v1 k2 v2 k3 v3  # 设置多个</span><br><span class="line">mget k1 k2 k3           # 获取多个</span><br><span class="line">msetnx                  # 不存在设置成功，存在设置失败（1个存在都失败，原子性）</span><br><span class="line">mget </span><br><span class="line"></span><br><span class="line">&lt;!-- 设置user对象 --&gt;</span><br><span class="line">&lt;!-- value为json来保存1个对象 --&gt;</span><br><span class="line">set user:1 &#123;name:zhangsan,age:3&#125;</span><br><span class="line">mset user:1:name zhangsan user:1:age 2  # mset user:&#123;id&#125;:&#123;field&#125;</span><br><span class="line">mget user:1name user:1:age</span><br><span class="line">set article:1000:views  #设置当前文章浏览量，key可以复用</span><br><span class="line"></span><br><span class="line">&lt;!-- 组合命令：如果不存再返回nil,如果存在返回旧值，并设置新值 --&gt;</span><br><span class="line">getset db redis         # 先get再set</span><br><span class="line">getset db mongoDB       # 得出来redis,再get db 为mongoDB </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>String使用场景：value可以是int、string，计数器、统计多单位数量、粉丝数、对象储存</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set uid:9555:follow 0 incr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-List类型"><a href="#2-2-List类型" class="headerlink" title="2.2.List类型"></a><strong>2.2.List类型</strong></h3><blockquote>
<p>基本数据类型，增加点规则玩成：栈、队列 所有List命令都是l开头</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lpush list one  # 将1个或多个插入到列表的头部</span><br><span class="line">lpush list two</span><br><span class="line">lrange list 0 -1</span><br><span class="line">rpush list one  # 将1个或多个插入到列表的底部</span><br><span class="line">lpop   # 去除左边的，头部</span><br><span class="line">rpop   # 去除右边的，底部</span><br><span class="line">Lindex list index  # 获取下表数值0</span><br><span class="line">Llen list   # 列表长度</span><br><span class="line">lrem list 1 one  # 移除list中的one且1个</span><br><span class="line">lrem list 2 one  # 移除list中的one且2个</span><br><span class="line">ltrim list 1 2  # 通过下表截取指定长度，list被改变，只剩下截取的元素</span><br><span class="line">rpoplpush source des # 移除列表的最后一个元素，且移动到新list</span><br><span class="line">lset list 0 item  # 指定下标添加时，list不存在就报错</span><br><span class="line">lpush list item</span><br><span class="line">lrange list 0 0</span><br><span class="line">lset list 0 newItem  # 若存在，把0号元素更新掉</span><br><span class="line">lset list 1 newItem  # 不存在的下标就把报错 </span><br><span class="line">linsert key befor|after pivot value # list前或后</span><br><span class="line">rpush list hello</span><br><span class="line">rpush list world</span><br><span class="line">linsert list before world other # 在world上面插入other</span><br><span class="line">linsert list after world other # 在world下面插入other</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>List实际是1个链条，key不存在创建新链表，key存在新增内容 空链表也代表不存在，两边改动效率 最高 Lpush Rpop：队列 Lpush Lpop：栈</p>
</blockquote>
<h3 id="2-3-Set-集合"><a href="#2-3-Set-集合" class="headerlink" title="2.3.Set(集合)"></a><strong>2.3.Set(集合)</strong></h3><blockquote>
<p>set中的值不能重复</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sadd myset hello        # 在myset中添加hello</span><br><span class="line">sadd myset kangshen  </span><br><span class="line">smembers myset          # 查看set所有制</span><br><span class="line">sismember myset hello   # 判断元素是否存在</span><br><span class="line">scard myset             # 查询set个数</span><br><span class="line">srem myset hello        # 移除hello</span><br><span class="line">srandmember myset       # 随机读取1个</span><br><span class="line">srandmember myset 2     # 随机读取指定个数</span><br><span class="line">spop myset              # 随机移除1个</span><br><span class="line">smove myset myset2 &quot;ku&quot; # 移动ku到myset2</span><br><span class="line">&lt;!-- 例子：共同关注：交集 --&gt;</span><br><span class="line">sdiff key1 key2         # 差集，显示不同的</span><br><span class="line">sinter key1 key2        # 交集:共同好友</span><br><span class="line">sunion key1 key2        # 并集</span><br><span class="line">&lt;!-- 例子：微博A用户所有关注的人放在SET集合中 --&gt;</span><br><span class="line">&lt;!-- 共同关注,共同爱好，六度理论 --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-4-Hash-Map"><a href="#2-4-Hash-Map" class="headerlink" title="2.4.Hash~Map"></a><strong>2.4.Hash~Map</strong></h3><blockquote>
<p>Map集合，key-value,村的也是键值对，但是value是个map集合</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hset key field value    # 添加key-value到Hash</span><br><span class="line">hget key field          # 获取keyHash中的field</span><br><span class="line">hmset myhash k1 v1 k2 v2# 插入多个值</span><br><span class="line">hmget myhash k1 k2      # 获取多个值</span><br><span class="line">hgetall myhash          # 获取所有的值</span><br><span class="line">hdel key field          # 删除field字段</span><br><span class="line">hlen key                # 获取hash表字段数量</span><br><span class="line">hexists myhash field    # 判断hash指定字段是否存在</span><br><span class="line"># 只获得所有field</span><br><span class="line">hkeys myhash</span><br><span class="line"># 后的所有的值</span><br><span class="line">kvals myhash</span><br><span class="line"># 指定自增 i++ &#x2F; i--</span><br><span class="line">hincrby myhash field3 1 </span><br><span class="line">hdecr myhash field 3 1 </span><br><span class="line">hsetnx myhash field4 hello  #不存在会创建，存在就不创建</span><br><span class="line">&lt;!-- 例子:hash变更数据,设置对象 --&gt;</span><br><span class="line">hset user:1 name qinjing</span><br><span class="line">hget user:1 name</span><br><span class="line">&lt;!-- hash更适合存储对象 --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-5-Zset-有序集合"><a href="#2-5-Zset-有序集合" class="headerlink" title="2.5.Zset(有序集合)"></a><strong>2.5.Zset(有序集合)</strong></h3><blockquote>
<p>在set的基础上，增加1个值，set k1 v1 / zset k1 score1 v1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zadd myzset 1 one           # 添加1个值</span><br><span class="line">zadd myzset 2 two 3 three   # 添加多个值</span><br><span class="line">zrange myset 0 -1           # 查询所有值</span><br><span class="line">&lt;!-- 排序 --&gt;</span><br><span class="line">zadd salary 2500 xiaohong 5000 zhangsan 500 kuangshen</span><br><span class="line">zrangebyscore salary -inf +inf              # 从小到大</span><br><span class="line">1) &quot;kuangshen&quot;</span><br><span class="line">2) &quot;xiaohong&quot; </span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">zrangebyscore salary -inf +inf withscores   # 从小到大，并输出score</span><br><span class="line">zrem salary xiaohong        # 移除小红</span><br><span class="line">zcard salary                # 获取个数</span><br><span class="line">zrevrange salary 0 -1       # 从大到小:反转</span><br><span class="line">zcount salary key min max   # 判断区间个数(闭区间)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>案例思路：set-&gt;排序、班级成绩表、工资表、带权重的消息、排行榜(有序集合zset中)</p>
</blockquote>
<h2 id="3-三种特殊数据类型"><a href="#3-三种特殊数据类型" class="headerlink" title="3.三种特殊数据类型"></a><strong>3.三种特殊数据类型</strong></h2><h3 id="3-1-geospatial地理位置"><a href="#3-1-geospatial地理位置" class="headerlink" title="3.1.geospatial地理位置"></a><strong>3.1.geospatial地理位置</strong></h3><blockquote>
<p>朋友的定位，附近的人，打车距离怎么算？城市经度纬度，redis3.2版本的geo就退出了。 只有6个命令：GEOADD、GEODIST、GEOHASH、GEOPOS、GEORADIUS、GEORADIUSBYMEMBER</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">geoadd                      #添加地理位置</span><br><span class="line">geoadd china:city 116.40 39.90 beijing</span><br><span class="line">geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">geoadd china:city 160.50 29.53 chongqing 114.05 22.52 shenzhen</span><br><span class="line"># 规则：两级无法直接添加，我们一般会下载城市数据，用JAVA一次导入</span><br><span class="line"># 参数：key 维度 精度 名称</span><br><span class="line">geopos key name             # 获取精度和纬度</span><br><span class="line"># geodist 单位，两地之间距离：</span><br><span class="line"># m 米</span><br><span class="line"># km 千米</span><br><span class="line"># mi 盈利</span><br><span class="line"># ft 英尺</span><br><span class="line">geodist key beijin shanghai km # 两地之间距离直线，单位千米</span><br><span class="line">&lt;!-- 例子：我附近的人,找朋友： --&gt;</span><br><span class="line">&lt;!-- georedius:以给定的经纬度为中心，找出半径内的元素 --&gt;</span><br><span class="line"># 1、记录所有人的经纬度</span><br><span class="line"># 2、获得所有附近的人的地址，定位最近的老师！</span><br><span class="line"># 以经纬度为精心，显示城市到我某距离内的指定人数</span><br><span class="line">georadius key logitude latitude radius m|km|ft|mi withdist withcoord count num</span><br><span class="line">georadius china:city 110 120 1000 km withdist withcoord count 3</span><br><span class="line"># 以经纬度为精心，显示城市到我有多远:距离</span><br><span class="line">georadius china:city 110 120 1000 km withdist</span><br><span class="line"># 以经纬度为精心，显示城市到我某距离内所有人到我的经纬度信息</span><br><span class="line">georadius china:city 110 120 1000 km withcoord</span><br><span class="line"># 以北京元素为中心找出距离我某距离的所有城市</span><br><span class="line">&lt;!-- 例子：导航定位，georadiusbymember：找出位于指定元素周围的其他元素 --&gt;</span><br><span class="line">georadiusbymember china:city beijing 1000 km</span><br><span class="line">georadiusbymember china:city shanghai 400 km</span><br><span class="line"># geohash:找到1个或多个元素的geohash表示:52点证书编码，返回11个字符的字符串，所以没有精度,还是两个元素距离：将二位经纬度转换为1维的经纬度hash字符串表示：2个字符串长得越像，越接近</span><br><span class="line">geohash china:city beijing shanghai </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>geo实现原理：基于Zset,可以使用Zset操作geo 所以用zset命令进行删除修改</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrange china:city 0 -1              # 查看所有城市</span><br><span class="line">zrem china:city beijing             # 删除北京</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-Hyperloglog基数统计"><a href="#3-2-Hyperloglog基数统计" class="headerlink" title="3.2.Hyperloglog基数统计"></a><strong>3.2.Hyperloglog基数统计</strong></h3><blockquote>
<p>什么是基数？不重复的元素 A {1,3,5,7,8,7} B {1,3,5,7,8} 基数：1,3,5,7,8 Redis 2.8.9 半根更新了Heyperloglog数据结构 统计网页UV(1个人访问1个网站多次，但是还算1个人) 传统方法，set保存用户id,然后用set元素数量作为统计标准 这种方式保存大量id比较麻烦，占内存。因为目的是计数，不是存id Hyperloglog： 优点:占用内存固定，2^64不同的元素，12kb内存。内存角度比较比set好 缺点:有0.81%的错误率</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PFadd key element [element ...]</span><br><span class="line">PFadd mykey a b c d e f g       # 添加数据到第一组</span><br><span class="line">PFadd mykey2 a b c d e f g      # 添加数据到第二组</span><br><span class="line">PFCOUNT mykey                   # 统计mykey中元素基数的数量</span><br><span class="line">PFMERGE mykey3 mykey mykey2     # 合并mykey与mykey2到mykey3：删除重复</span><br><span class="line">PFCOUNT mykey3                  # 查看并集的数量</span><br><span class="line"># 如果允许容错，一定要使用Hyperloglog !</span><br><span class="line"># 如果不允许容错，就要使用set或者自己的数据类型 !</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-3-Bitmaps-位存储"><a href="#3-3-Bitmaps-位存储" class="headerlink" title="3.3.Bitmaps 位存储"></a><strong>3.3.Bitmaps 位存储</strong></h3><blockquote>
<p>筛选用户：用0101最快: 例子：1、统计疫情感染人数：0 1 0 1 0 1，2、活跃不活跃，3、是否登录，4、打卡（mysql:user: status date）这样很慢，所有两个状态都可以使用Bitmaps! Bitmaps位图，数据结构！都是操作魏晋至进行记录，就只有0和1两个状态。 365天 = 365bit/8bit = 46kb</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用bitmap记录周一到周日打卡！ --&gt;</span><br><span class="line"># 周一：1 周二：0 周三：1 周四：1 周五：0 周六：1 周日：1</span><br><span class="line"># 统计有多少个1</span><br><span class="line">setbit sign 1 0</span><br><span class="line">setbit sign 2 0</span><br><span class="line">setbit sign 3 0</span><br><span class="line">setbit sign 4 0</span><br><span class="line">setbit sign 5 0</span><br><span class="line">setbit sign 6 0</span><br><span class="line">setbit sign 7 0</span><br><span class="line">getbit sign 1</span><br><span class="line">getbit sign 2</span><br><span class="line">getbit sign 3</span><br><span class="line">getbit sign 4</span><br><span class="line">getbit sign 5</span><br><span class="line">getbit sign 6</span><br><span class="line">getbit sign 7</span><br><span class="line"># 统计打卡天数</span><br><span class="line">bitcount sign [start end]</span><br><span class="line">bitcount sign                       # 统计打卡天数，默认所有</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-Redis的基本事务操作"><a href="#4-Redis的基本事务操作" class="headerlink" title="4.Redis的基本事务操作"></a><strong>4.Redis的基本事务操作</strong></h2><blockquote>
<p>redis单条命令保存原子性，但是redis事务不保证原子性，没有隔离集合概念！ Redis事务本质：一组命令的集合！一个手游命令被序列化，进行顺序执行！ 一次性、顺序性、排他性！这样执行一系列命令 redis的事务：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 正常执行事务：</span><br><span class="line">1、开启事务(multi)</span><br><span class="line">2、命令入队(...)</span><br><span class="line">&gt;set k1 v1</span><br><span class="line">&gt;set k2 v2</span><br><span class="line">&gt;get k2</span><br><span class="line">3、执行事务(exec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行完后都要重新开启新事务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 放弃执行事务：</span><br><span class="line">1、开启事务(multi)</span><br><span class="line">2、命令入队(...)</span><br><span class="line">&gt;set k1 v1</span><br><span class="line">&gt;set k2 v2</span><br><span class="line">&gt;get k2</span><br><span class="line">3、取消事务(discard)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行错误: 1、编译型异常(代码问题~命令问题):事务所有命令不会执行. multi set k1 v1 setget k1 v1 exec EXECABORT Transaction discarded because of previous errors. 2、运行异常(1/0):若事务命令存在语法错误，其他命令可以正常执行，错误命令抛出异常. multi incr k1 set k1 v1 exec ERR value is not an integer or out of range</p>
</blockquote>
<h2 id="5-监控！Watch：Redis实现乐观锁、悲观锁"><a href="#5-监控！Watch：Redis实现乐观锁、悲观锁" class="headerlink" title="5.监控！Watch：Redis实现乐观锁、悲观锁"></a><strong>5.监控！Watch：Redis实现乐观锁、悲观锁</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 悲观锁：</span><br><span class="line">· 很悲观，认为什么时候都出问题，所以什么时候都会加锁！</span><br><span class="line"># 乐观锁：</span><br><span class="line">· 很乐观，认为什么时候都不会出现问题，什么时候都不上锁，更新时候会判断一下，此期间是否有人修改过这个数据</span><br><span class="line">· 获取version</span><br><span class="line">· 更新时候比较version</span><br><span class="line">· 常用，效率高</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Redis监视测试</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 正常执行：成功</span><br><span class="line">multi                       # 开启事务</span><br><span class="line">set money 100               # 钱包100元</span><br><span class="line">get out 0                   # 记录支出0</span><br><span class="line">watch money                 # 监视money钱包</span><br><span class="line">decrby money 20             # 钱包花去20</span><br><span class="line">incrby out 20               # 支出增加20</span><br><span class="line">exec                        # 执行事务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>watch相当于乐观锁</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 多个窗口执行时：</span><br><span class="line">1:watch money                 # 线程1：监视钱包</span><br><span class="line">1:multi                       # 线程1：开启事务</span><br><span class="line">1:decrby money 20             # 线程1：钱包花去20</span><br><span class="line">1:incrby out 20               # 线程1：支出增加20</span><br><span class="line">2:get money                   # 线程2：查看钱包</span><br><span class="line">2:set money 1000              # 线程2：修改钱包</span><br><span class="line">1:exec                        # 线程1：执行事务时，前边的watch会提醒当前事务一定执行失败，因为线程2修改了我们的值，执行失败</span><br><span class="line">&gt;nil                          # 修改失败</span><br><span class="line">1:unwatch                     # 事务执行失败先解锁，放弃监视</span><br><span class="line">1:watch monet                 # 再监视获取最新的值，执行别的操作</span><br><span class="line">1:exec                        # 执行事务时会比对监视的值是否发生变化</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分布式秒杀乐观锁</p>
</blockquote>
<h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6.Jedis"></a><strong>6.Jedis</strong></h2><blockquote>
<p>我们要使用JAVA来操作Redis 什么是Jedis?是Redis官方推荐的java连接工具！使用Java操作Redis中间件！如果你要是用java操作redis，那么一定要对jedis十分熟悉. 1、导入依赖</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;fastjson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.62&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、编码测试 2.1.连接数据库 2.2.操作命令 2.3.断开连接</p>
<h2 id="7-SpringBoot整合"><a href="#7-SpringBoot整合" class="headerlink" title="7.SpringBoot整合"></a><strong>7.SpringBoot整合</strong></h2><blockquote>
<p>springboot操作数据：springdata封装了 jpa jdbc mongdb redis，springdata也是和springboot齐名的项目 说明：在springboot2.x之后，原来的jedis替换为lettuce! jedis:采用直连：多线程不安全，避免不安全，得用jedis pool连接池！更像BIO模式 lettuce:采用netty异步请求，实例可以在多个线程中共享，不存在线程不安全的情况！更像NIO模式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">源码分析：</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Copyright 2012-2020 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      https:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">package org.springframework.boot.autoconfigure.data.redis;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.Import;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisOperations;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * &#123;@link EnableAutoConfiguration Auto-configuration&#125; for Spring Data&#39;s Redis support.</span><br><span class="line"> *</span><br><span class="line"> * @author Dave Syer</span><br><span class="line"> * @author Andy Wilkinson</span><br><span class="line"> * @author Christian Dupuis</span><br><span class="line"> * @author Christoph Strobl</span><br><span class="line"> * @author Phillip Webb</span><br><span class="line"> * @author Eddú Meléndez</span><br><span class="line"> * @author Stephane Nicoll</span><br><span class="line"> * @author Marco Aust</span><br><span class="line"> * @author Mark Paluch</span><br><span class="line"> * @since 1.0.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration(proxyBeanMethods &#x3D; false)</span><br><span class="line">@ConditionalOnClass(RedisOperations.class)</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="line">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean(name &#x3D; &quot;redisTemplate&quot;)</span><br><span class="line">	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br><span class="line">	public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">		&#x2F;&#x2F; 默认的RedisTemplate没有过多的设置，redis对象都是需要序列化！Dubbo</span><br><span class="line">		&#x2F;&#x2F; 两个反省都是object,object类型，后续使用都要强转</span><br><span class="line">		&#x2F;&#x2F; 我们可以自己定义一个RedisTemplate</span><br><span class="line">		RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate&lt;&gt;();</span><br><span class="line">		template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">		return template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br><span class="line">	&#x2F;&#x2F;由于String是Redis中最常用的类型,所以我们要单独提出来一个bean！</span><br><span class="line">	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">		StringRedisTemplate template &#x3D; new StringRedisTemplate();</span><br><span class="line">		template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">		return template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>整合测试一下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">1.导入配置</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">2.配置连接</span><br><span class="line"># Springboot 所有得配置类都有一个自动配置类 RedisAutoConfiguration</span><br><span class="line"># 自动配置类都会绑定一个properties配置文件  RedisProperties</span><br><span class="line">spring.redis.host&#x3D;127.0.0.1</span><br><span class="line">spring.redis.port&#x3D;6379</span><br><span class="line"># spring.redis.database&#x3D;0</span><br><span class="line"># spring.redis.lettuce.pool.max-active&#x3D;</span><br><span class="line"></span><br><span class="line">3.测试！</span><br><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line">import java.time.Duration;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class RedisSpringbootApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，类似String</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;name&quot;,&quot;yuhang&quot;);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;));</span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，List</span><br><span class="line">        redisTemplate.opsForList().leftPush(&quot;name&quot;,&quot;yuhang&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，Set</span><br><span class="line">        redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，Hash</span><br><span class="line">        redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，Geo</span><br><span class="line">        redisTemplate.opsForGeo();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，ZSet</span><br><span class="line">        redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，HyperLogLog</span><br><span class="line">        redisTemplate.opsForHyperLogLog();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; redis操作字符串的，Bitmap</span><br><span class="line">        redisTemplate.opsForCluster();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 常用的操作,直接用redisTemplate</span><br><span class="line">        &#x2F;&#x2F; 比如事务和基本的CRUD</span><br><span class="line">        redisTemplate.multi();</span><br><span class="line">        redisTemplate.watch(&quot;&quot;);</span><br><span class="line">        redisTemplate.exec();</span><br><span class="line">        redisTemplate.delete(&quot;&quot;);</span><br><span class="line">        redisTemplate.expire(&quot;&quot;, Duration.ZERO);</span><br><span class="line">        redisTemplate.move(&quot;&quot;, 1);</span><br><span class="line">        &#x2F;&#x2F; 获取链接,操作数据方法</span><br><span class="line">        RedisConnection redisConnection &#x3D; redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        redisConnection.flushAll();</span><br><span class="line">        redisConnection.flushDb();</span><br><span class="line">        redisConnection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">\\ 编写自己的序列化配置</span><br><span class="line">package com.example.config;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line">import com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 固定的模板</span><br><span class="line">    &#x2F;&#x2F; 编写我们自己的RedisTemplate</span><br><span class="line">    @Bean</span><br><span class="line">    @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        &#x2F;&#x2F; 我们为了自己方便一般用String, Object类型</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; json序列化配置,转义：</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; string序列化配置</span><br><span class="line">        StringRedisSerializer stringRedisSerializer &#x3D; new StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 配置具体的序列化方式,配置自己的序列化</span><br><span class="line">        &#x2F;&#x2F; key采用string序列化</span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        &#x2F;&#x2F; hash的key也用sting序列化</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        &#x2F;&#x2F; value使用json序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        &#x2F;&#x2F; hash的value使用json序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有的redis操作，对于开发人员来说，重要的是要理解redis的思想和每一种数据结构的用处与作用场景</p>
</blockquote>
<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a><strong>高级</strong></h1><h2 id="8-Redis-conf详解"><a href="#8-Redis-conf详解" class="headerlink" title="8.Redis.conf详解"></a><strong>8.Redis.conf详解</strong></h2><blockquote>
<p>启动时候通过配置文件启动的！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 单位:units大小写不敏感</span><br><span class="line"># Redis configuration file example.</span><br><span class="line">#</span><br><span class="line"># Note that in order to read the configuration file, Redis must be</span><br><span class="line"># started with the file path as first argument:</span><br><span class="line">#</span><br><span class="line"># .&#x2F;redis-server &#x2F;path&#x2F;to&#x2F;redis.conf</span><br><span class="line"></span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k &#x3D;&gt; 1000 bytes</span><br><span class="line"># 1kb &#x3D;&gt; 1024 bytes</span><br><span class="line"># 1m &#x3D;&gt; 1000000 bytes</span><br><span class="line"># 1mb &#x3D;&gt; 1024*1024 bytes</span><br><span class="line"># 1g &#x3D;&gt; 1000000000 bytes</span><br><span class="line"># 1gb &#x3D;&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 包含文件</span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line"># Include one or more other config files here.  This is useful if you</span><br><span class="line"># have a standard template that goes to all Redis servers but also need</span><br><span class="line"># to customize a few per-server settings.  Include files can include</span><br><span class="line"># other files, so use this wisely.</span><br><span class="line">#</span><br><span class="line"># Notice option &quot;include&quot; won&#39;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="line"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line"># line as value of a configuration directive, you&#39;d better put includes</span><br><span class="line"># at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line">#</span><br><span class="line"># If instead you are interested in using includes to override configuration</span><br><span class="line"># options, it is better to use include as the last line.</span><br><span class="line"># 导入文件</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br><span class="line"></span><br><span class="line">################################## MODULES #####################################</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 网络</span><br><span class="line">bind 127.0.0.1      #绑定ip</span><br><span class="line">protected-mode yes  # 保护模式</span><br><span class="line">port 6379           # 端口设置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 通用配置</span><br><span class="line">daemonize yes       # 以守护的方式进行，默认no不开启</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid             #如果以后太方式运行需要文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 日志</span><br><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development&#x2F;testing)              # 开发阶段</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)    # debug</span><br><span class="line"># notice (moderately verbose, what you want in production probably)         # 生产环境</span><br><span class="line"># warning (only very important &#x2F; critical messages are logged)              # 警告</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">logfile &quot;&quot;          # 日志文件位置名，</span><br><span class="line">database 16         # 数据库数量，默认16</span><br><span class="line">always-show-logo yes# 是否总是显示露沟</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># RDB</span><br><span class="line"># 快照：持久化时，在规定时间内执行了多少次操作会持久化生成文件(.rdb&#x2F;aof)</span><br><span class="line"># 若不持久化就会丢</span><br><span class="line"># 持久化规则,我们以后自己定义</span><br><span class="line">save 900 1          # 如果1个key进行了修改在900s内就进行持久化操作</span><br><span class="line">save 300 10         # 如果10个key进行了修改在300s内就进行持久化操作</span><br><span class="line">save 60 10000       # 如果10000个key进行了修改在60s内就进行持久化操作，高并发</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes # 持久化出错是否还继续持久化操作</span><br><span class="line"></span><br><span class="line">rdbcompression yes              # 是否压缩rdb文件，耗cpu资源</span><br><span class="line">rdbchecksum yes                 # 保存时是否检查rdb文件校验并修复</span><br><span class="line">dir .&#x2F;                          # rdb保存目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># REPLICATION 主从复制时再看，多个Redis</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 密码</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span><br><span class="line"># commands.  This might be useful in environments in which you do not trust</span><br><span class="line"># others with access to the host running redis-server.</span><br><span class="line">#</span><br><span class="line"># This should stay commented out for backward compatibility and because most</span><br><span class="line"># people do not need auth (e.g. they run their own servers).</span><br><span class="line">#</span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared</span><br><span class="line"># 密码</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># 命令设置获取密码</span><br><span class="line">config get requirpass</span><br><span class="line">config set requirpass &quot;123456&quot;</span><br><span class="line">auth 123456                 # 验证密码登录</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLIENTS客户端限制配置，一般不管</span><br><span class="line">maxclients 10000            # 设置redis最大客户端数量</span><br><span class="line">maxmemory                   # 最大内存数量</span><br><span class="line">maxmemory-policy noeviction # 内存到达上限之后的处理策略：juc线程池满了处罚四种策略，# 移除过期的key、报错、等6种</span><br><span class="line">    1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span><br><span class="line">    2、allkeys-lru ： 删除lru算法的key   </span><br><span class="line">    3、volatile-random：随机删除即将过期key   </span><br><span class="line">    4、allkeys-random：随机删除   </span><br><span class="line">    5、volatile-ttl ： 删除即将过期的   </span><br><span class="line">    6、noeviction ： 永不过期，返回错误</span><br><span class="line">lazyfree                    # 释放内存</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APPEND ONLY模式|AOF模式设置</span><br><span class="line">appendonly no               # 默认不开启，默认RDB方式用来持久化，一般够用了，rdb完全够用了</span><br><span class="line">appendfilename &quot;*.aof&quot;      # aof持久化文件 </span><br><span class="line">appendfsync everysec        # 每秒同步可能会丢失1秒的数据；always每次都同步，速度慢；no不同步</span><br></pre></td></tr></table></figure>
<h2 id="9-Redis持久化"><a href="#9-Redis持久化" class="headerlink" title="9.Redis持久化"></a><strong>9.Redis持久化</strong></h2><blockquote>
<p>面试和工作，持久化是重点！ Redis是内存数据库，如果不讲内存中的数据库状态保存到磁盘，一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化功能！ 在主从复制中，rdb是备用的。备用在从机上面，不占用主机内存，aof一般不用</p>
</blockquote>
<h3 id="9-1-RDB-Redis-DataBase"><a href="#9-1-RDB-Redis-DataBase" class="headerlink" title="9.1.RDB (Redis DataBase)"></a><strong>9.1.RDB (Redis DataBase)</strong></h3><p>什么是RDB?</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/RDB.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/RDB.png"></p>
<blockquote>
<p>在指定的时间间隔内写入磁盘，储存snapshot快照，恢复时是讲快照文件直接读到内存里。</p>
</blockquote>
<blockquote>
<p>Redis会单独创建（fork）一个进程来进行持久化，会先将数据写入到一个临时RDB文件中，待持久化过程结束了，用临时文件替换上次的持久化好的文件，退出子进程。整个过程中主进程不进行任何IO操作的，确保了极高的性能。</p>
</blockquote>
<blockquote>
<p>如果需要进行大规模数据的回复，且对于回复的完整性不是非常敏感，那RDB方式更加的搞笑。RDB的缺点是最后一次持久化后的数据可能丢失. 我们默认使用RDB，一般情况下不需要修改这个配置！</p>
</blockquote>
<p>==rdb保存的文件是dump.rdb==,在配置文件“dbfilename dump.rdb”行中配置 ==在生产环境我们会备份rdb文件==</p>
<blockquote>
<p>触发机制 1.save条件满足 2.flush all 默认产生一个rdb 3.推出Redis时自动产生rdb文件 备份完成后自动生成一个rdb文件</p>
</blockquote>
<blockquote>
<p>恢复rdb文件 1.只需要讲rdb文件放到redis启动目录下，redis启动时自动检查dump.rdb回复其中的数据。全自动 2.config get dir 查看存放位置，把rdb文件放到这里，启动redis会自动扫描完后恢复</p>
</blockquote>
<blockquote>
<p>优点 1.适合大规模的数据恢复，宕机了别删除rdb。 2.对数据完整性不高时。若设置60s，在59秒时宕机时10000条数据就会丢失。 缺点 1.需要一定的时间间隔，如果redis意外宕机了，最后一次修改的数据就没有了。 2.当fork一个进程时需要一个内存空间。</p>
</blockquote>
<h3 id="9-2-AOF-Append-Only-File"><a href="#9-2-AOF-Append-Only-File" class="headerlink" title="9.2.AOF (Append Only File)"></a><strong>9.2.AOF (Append Only File)</strong></h3><p>什么是AOF?</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/AOF.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/AOF.png"></p>
<blockquote>
<p>以日志的方式来记录每个写操作，将Reids执行过的所有指令记录下在(读操作不记录)。只追加文件但不改写文件，redis启动时读写文件重构建数据，redis重启的话根据日志文件内容将写指令从前到后执行一次，完成数据恢复的操作。 AOF保存的文件为appendonly.aof 默认不开启,将appendonly yes,重启redis就生效。aof文件有问题启动不了redis</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决问题：</span><br><span class="line">ps -ef|grep redis   &#x2F;&#x2F;redis没开启</span><br><span class="line"># 用redis-check-aof自动修复文件</span><br><span class="line">redis-check-aof --fix appendonly.aof</span><br><span class="line">yes</span><br><span class="line"># 重启就恢复成功，但是有一些会删除掉</span><br></pre></td></tr></table></figure>
<p>== ABD是全丢，AOF是丢失部分 ==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">appendfsync always              # 每次修改都会sync,消耗性能</span><br><span class="line">appendfsync everysec            # 每秒执行一次sync,可能丢失1s数据</span><br><span class="line">appendfsync no                  # 不执行sync，操作系统自己同步数据，速度最快</span><br><span class="line"># 重写规则，redis记录上次文件大小，大于64mb时，重新fork新进程将文件重写</span><br><span class="line">no-appendfsync-no-rewirte no    # 默认不打开，文件无线的追加，文件会越来越大，开启后保证aof体积不要太大</span><br><span class="line">auto-aof-rewirte-percentage 100 # </span><br><span class="line">auto-aof-rewirte-min-size 64mb  # </span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点 1.每次修改都同步，文件完整性更好 2.默认开启每秒同步一次 2.no 从不同步效率最高 缺点 1.相对据数据文件，aof文件远远大于rdb，修复速度比rdb慢 2.AOF运行效率比rdb慢，redis默认为rdb持久化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拓展：</span><br><span class="line">只做缓存，如果你希望数据仅在服务器运行的时候存在，不用开启持久化</span><br><span class="line">两种持久化同时开启，会使用aof来恢复数据。</span><br><span class="line">建议在从机上使用rdb，15分钟备份一次 save 900 1</span><br><span class="line">如果不开启aof，仅靠Master-Salve-Replication实现高性能也可以。减少了rewirte打来的系统开销，如果断电Master&#x2F;Salve，就会把所有数据都丢掉了,启动脚本会比较Master与Salve的rdb文件，恢复最新的。微博就是这种架构。</span><br></pre></td></tr></table></figure>
<h2 id="10-Redis发布订阅"><a href="#10-Redis发布订阅" class="headerlink" title="10.Redis发布订阅"></a><strong>10.Redis发布订阅</strong></h2><blockquote>
<p>Redis发布/订阅，是一种消息通信模式：发送者发送消息(pub)，订阅者就收消息(sub)，微信、微博、关注系统！还有rabbitmq、kafka Redis发布消息图,用list也可以做，第一个：消息发送者，第二个：频道，第三个：消息订阅者  下图展示了频道channel1，以及订阅这个频道的客户端–clent2，clent5，clent1，之间的关系：  当有新消息时，通过publish命令发送给频道channel1时，这个消息会被发送给订阅它的三个客户端：  命令： 这些命令被广泛用于构建即时通讯应用，比如网络聊天和实时广播、实时提醒等：</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/1.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/2.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/2.png"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/3.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/3.png"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/4.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/4.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#订阅者-窗口1-自动监听</span><br><span class="line">redis-cli -p 6379</span><br><span class="line">subscribe kangshenshuo</span><br><span class="line"># 等待推送者发布信息</span><br><span class="line"># 收到信息，格式：</span><br><span class="line"># message               # 消息</span><br><span class="line"># kuangshenshuo         # 消息的频道</span><br><span class="line"># hello,kuangshen       # 消息内容</span><br><span class="line">#发布者-窗口2-发布消息</span><br><span class="line">redis-cli -p 6379</span><br><span class="line">publish kuangshenshuo &quot;hello,kuangshen&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis是c实现的，通过分析源码pubsub.c文件，了解底层机制</span><br><span class="line">通过subscribe订阅一个频道后，redis-server里维护1个字典，字典的键是1个个频道，字典的值是1个链表。链表中保存者订阅这个频道的所有channel的客户端，subscribe命令的关键是将客户端添加给给定的channel订阅链表中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/5.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/5.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过publish发送消息给订阅者，redis-server会使用给定的频道作为关键字，找出它维护的链表中的所有订阅这个频道的客户端，发送消息给他们</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用场景</span><br><span class="line">1、实时消息系统</span><br><span class="line">2、实时聊天，频道当作聊天室，将信息回显给所有人</span><br><span class="line">3、订阅关注系统</span><br><span class="line"># 复杂场景会使用消息中间件来做：kafka、rebitmq</span><br></pre></td></tr></table></figure>
<h2 id="11-Redis主从复制"><a href="#11-Redis主从复制" class="headerlink" title="11.Redis主从复制"></a><strong>11.Redis主从复制</strong></h2><blockquote>
<p>概念：主从复制，复制1台redis数据到另一台,数据的复制是单向的，智能由主节点到从节点。master以写为主，slave以读为主。 默认情况下，每台redis都是一个主节点。 主从复制作用主要包括：</p>
</blockquote>
<blockquote>
<p>1、数据冗余：主从复制实现数据的热备份，是持久化外的一种数据冗余方式！</p>
</blockquote>
<blockquote>
<p>2、故障恢复：当主节点出现问题，还可以由节点提供服务，实现快速故障恢复。</p>
</blockquote>
<blockquote>
<p>3、负载均衡：配合读写分离，主节点提供写服务，从节点提供读服务，分担服务器负载。</p>
</blockquote>
<blockquote>
<p>4、高可用集群：除以上外，主从复制还是哨兵和集群能够实施的基础。</p>
</blockquote>
<blockquote>
<p>一般来说：要将redis运用到项目中去，必须一主二从3个服务器，原因如下：</p>
</blockquote>
<ol>
<li>从结构上，单个redis服务器会发生单点故障，并且1台服务器需要处理所有的请求负载，压力较大。</li>
<li>从容量上来说，单个redis服务器内存容量是有限的。单台redis最大使用内存不应该超过20g。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/6.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/6.png"></p>
<blockquote>
<p>电商商品都是1次上传，无数次浏览，多读少写。 80%的情况下都是在读，把压力放到从机上，减缓主机服务器压力。一主二从，最少3台。</p>
</blockquote>
<blockquote>
<p>环境配置：只配置从库，因为默认是主库</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">编写3个配置文件启动3个配置服务。</span><br><span class="line"># 启动服务</span><br><span class="line">redis-server kconfig&#x2F;redis.config</span><br><span class="line"># 连接</span><br><span class="line">redis-cli -p 6379</span><br><span class="line">info replication        # 打印主从复制信息,查看当前库信息</span><br><span class="line"># 打开3个端口</span><br><span class="line"># 修改配置文件，copy多个：redis.conf、redis1.conf、redis2.conf、redis3.conf</span><br><span class="line">redis1.conf：   </span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6001.pid</span><br><span class="line">logfile &quot;1.log&quot;</span><br><span class="line">dbfilename dump1.rdb</span><br><span class="line">prot 6001</span><br><span class="line"></span><br><span class="line">redis2.conf：</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6002.pid</span><br><span class="line">logfile &quot;2.log&quot;</span><br><span class="line">dbfilename dump2.rdb</span><br><span class="line">prot 6002</span><br><span class="line"></span><br><span class="line">redis3.conf：</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6003.pid</span><br><span class="line">logfile &quot;3.log&quot;</span><br><span class="line">dbfilename dump3.rdb</span><br><span class="line">prot 6003</span><br><span class="line"># 修改对应内容：</span><br><span class="line">1.端口号</span><br><span class="line">2.pid名字</span><br><span class="line">3.log名字</span><br><span class="line">4.备份文件dump.rdb文明 </span><br><span class="line"></span><br><span class="line"># 单机多集群-启动：</span><br><span class="line">redis-server kconfig&#x2F;redis.config</span><br><span class="line">redis-cli -p 6379</span><br><span class="line"></span><br><span class="line">redis-server kconfig&#x2F;redis1.config</span><br><span class="line">redis-cli -p 6001</span><br><span class="line"></span><br><span class="line">redis-server kconfig&#x2F;redis2.config</span><br><span class="line">redis-cli -p 6002</span><br><span class="line"></span><br><span class="line">redis-server kconfig&#x2F;redis3.config</span><br><span class="line">redis-cli -p 6003</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一主二从： 默认每一台都是主节点，查看主从信息：info replication，都是主机，开始配置从机(一般只配置从机，找老大) 主（6379），从（6001，6002，6003）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">从机6001:</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">info replication</span><br><span class="line"></span><br><span class="line">从机6002:</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">info replication</span><br><span class="line"></span><br><span class="line">从机6003:</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">info replication</span><br><span class="line"></span><br><span class="line">主机6379：</span><br><span class="line">info replication</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>真是的主从配置应该在文件中配置，文件中配置是永久的，命令行是暂时的。</p>
</blockquote>
<blockquote>
<p>文件配置：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPLICATION</span><br><span class="line">replicaof masterip masterport       # 主机ip和port </span><br><span class="line">masterauth                          # 主机密码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>细节：主机可以写，从机不能写，只能读，主机中的所有数据自动被从机保存。</p>
</blockquote>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主机：</span><br><span class="line">set k1 v1 </span><br><span class="line">从机：</span><br><span class="line">get k1</span><br><span class="line">set k2 v2</span><br><span class="line"># READONLY You can&#39;t write against a read only replica.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>主机才能写，从机不能写。</p>
</blockquote>
<blockquote>
<p>测试主机断掉</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主机：</span><br><span class="line">shutdown</span><br><span class="line">从机：</span><br><span class="line">info replication</span><br><span class="line"># 如果主机端了，从机必须手动改配置。</span><br><span class="line"># 主机断开重新上线后，从机依旧连接到主机，获取到数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试从机断掉</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">从机：</span><br><span class="line">shutdown</span><br><span class="line">主机：</span><br><span class="line">info replication</span><br><span class="line">set k3 v3</span><br><span class="line">从机:</span><br><span class="line">get k3</span><br><span class="line">nil</span><br><span class="line"># 默认断开重启之后，只要没配置到文件配置中，默认变回主机。原先复制的数据还在，再变成从机还可以拿到主机数据。只要变回从机立马从主机中获取值。</span><br><span class="line">全量复制：从机连接主机第一次，全复制</span><br><span class="line">增量复制：已经连接，之后会把增加的复制过来</span><br><span class="line"># </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>层层链路：</p>
</blockquote>
<blockquote>
<p>master-&gt;slave-&gt;slave,三个连在一起，m断了，第一个s能不能写呢,第一个s依旧是从节点不能写入。</p>
</blockquote>
<blockquote>
<p>谋朝篡位： 如果没有老大master了，能不能选出新老大，能，得手动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从机：</span><br><span class="line">slaveof no one # 自己当老大</span><br><span class="line"># 如果老大回来了，得重新配置连接</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"># 一层一层变动</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="12-哨兵模式："><a href="#12-哨兵模式：" class="headerlink" title="12.哨兵模式："></a><strong>12.哨兵模式：</strong></h2><p>（如果没有老大master了，自动选取新老大。）</p>
<blockquote>
<p>概念：</p>
</blockquote>
<p>谋朝篡位自动版，能够监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供哨兵模式的命令，哨兵是个独立的进程，它会独立运行。原理是哨兵通过发送指令，等待redis服务器响应，从而监控运行的多个redis实例。</p>
<p>单机哨兵：  命令：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/7.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/7.png"></p>
<ol>
<li>redis-sentinel</li>
</ol>
<p>这里哨兵的两个作用：</p>
<ol>
<li>通过发送命令，让redis服务器返回运行状态，包括主从机服务器。</li>
<li>当哨兵检测到master舵机，自动将slave转为master，然后通过发布订阅模式通知其他的从服务器，修改配置文件让它转换为主机</li>
</ol>
<p>然而一个哨兵进程对redis服务器监控，可能出现问题，为此我们使用多哨兵进行监控。各个哨兵之间进行监控。6个进程</p>
<p>多哨兵模式：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/8.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/8.png"></p>
<p>假设主服务器舵机，哨兵1先检测结果，系统不会立马进行failover过程，这仅仅是哨兵1主观的认为主服务器不可用，这个现象叫主观下线。当后面的哨兵也发现主服务器不可用，并且当数量达到一定值，他们认为主服务器彻底凉掉了。那么哨兵们进行一次投票（投票算法），后进行failover故障转移操作。转移之后，就会发布订阅模式，让哨兵把自己监控的从服务器切换为主机，这个过程为客观下线。</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>目前状态1主3从，配置哨兵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1.创建哨兵文件配置：</span><br><span class="line">vim sentinel.conf：</span><br><span class="line"># sentinel monitor 监控名称 ip port </span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1 </span><br><span class="line"># 监控主机,1代表主机挂了，从机会投票找新主机，票数多着成为主机</span><br><span class="line"></span><br><span class="line"># 2.启动哨兵</span><br><span class="line">redis-sentinel sentinel.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主机：</span><br><span class="line">shutdown</span><br><span class="line"></span><br><span class="line">从机01：</span><br><span class="line">info replication # 现在它还是从机,哨兵过一会再选举，进行故障转移</span><br><span class="line"></span><br><span class="line">从机02：</span><br><span class="line">info replication </span><br><span class="line"># 自动变为了master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果master节点断开了，从从中随机选择1个转为主机。 哨兵日志有输出记录，新机回来了只能当从机，自动扫描并规定到新主机下当从机，这就是哨兵模式的规则</p>
<p>优点：</p>
<p>1)哨兵集群，基于主从复制，所有的主从配置优点他都有</p>
<p>2)主从可以切换，故障可以转移，系统可用性会更好 3)哨兵模式就是主从复制的升级，手动到自动，更加健壮</p>
<p>缺点：</p>
<p>1)redis不好在线扩容，当配置文件写死了更麻烦，在线扩容麻烦</p>
<p>2)实现哨兵配置很麻烦，里面有很多选择</p>
<blockquote>
<p>哨兵全部配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵sentinel实例运行的端口，多个哨兵配置多个端口</span><br><span class="line">prot 6379</span><br><span class="line"></span><br><span class="line"># 哨兵工作目录文件</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"></span><br><span class="line"># 哨兵监控的redis主节点的ip port</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 prot quorum</span><br><span class="line"></span><br><span class="line"># 当redis实例开启时requirepass foobared 授权密码，这样所有连接redis实例的客户端都要提供密码</span><br><span class="line">sentinel auth-pass mymaster password</span><br><span class="line"></span><br><span class="line"># 指定转换延迟秒数，默认30秒</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 配置当某一事件发生需要执行的脚本</span><br><span class="line"># 脚本规则：</span><br><span class="line"># 脚本执行返回1：那么该脚本稍后会再次执行，重复执行数默认为10 </span><br><span class="line"># 脚本执行返回2：或者比2更大的数，脚本将不会再执行</span><br><span class="line"># 脚本被终端默认返回1，脚本最大执行时间为60s，超过60s，被sigkill信号终止，之后重新进行。</span><br><span class="line"></span><br><span class="line"># 通知类脚本：</span><br><span class="line"># 当sentinel有任何警告级别事件(主观、客观下线)，都会调用脚本，脚本应该通过邮件或sms形式通知管理员。调用该脚本将传给脚本2个参数，一个是事件的类型，一个是事件的描述，如果配置了脚本路径，必须存在该文件，否则sentinel启动不了</span><br><span class="line"></span><br><span class="line">#通知脚本：</span><br><span class="line">sentinel notification-script mymaster &#x2F;var&#x2F;redis&#x2F;notify.sh</span><br><span class="line"></span><br><span class="line">#客户端重新配置主节点参数脚本：</span><br><span class="line">#当一个master由于failover发生改变时，调用该脚本，通知相关客户端关于master的地址已经改变的信息。</span><br><span class="line">#一下参数将会在调用时传递给脚本：</span><br><span class="line">#master-name role state from-ip from-port to-ip to-port</span><br><span class="line">#目前state总是failover</span><br><span class="line">#role是leader或者observer中1个</span><br><span class="line">#参数from-ip from-port to-ip to-port是用来和旧的master和新的master通信的</span><br><span class="line">#这个脚本应该是通用的能被多次调用的，不是针对性的</span><br><span class="line">#sentinel client-reconfig-script master-name script-path</span><br><span class="line">#sentinel client-reconfig-script mymaster &#x2F;var&#x2F;redis&#x2F;reconfig.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>高级程序员：springboot、springcloud、架构、大数据、elk</p>
<h2 id="13-Redis缓存穿透和雪崩"><a href="#13-Redis缓存穿透和雪崩" class="headerlink" title="13.Redis缓存穿透和雪崩"></a><strong>13.Redis缓存穿透和雪崩</strong></h2><blockquote>
<p>都是服务高可用问题</p>
</blockquote>
<h3 id="13-1-缓存穿透（查不到）"><a href="#13-1-缓存穿透（查不到）" class="headerlink" title="13.1.缓存穿透（查不到）"></a><strong>13.1.缓存穿透（查不到）</strong></h3><blockquote>
<p>概念:</p>
</blockquote>
<p>读的请求先去redis中查，如果缓存中没有就去数据库中查询 如果jmeter，压力测试器或多请求客户端一直请求mysql，当很多时，给数据库造成很大压力。mysql崩了。</p>
<blockquote>
<p>解决方案:</p>
</blockquote>
<ol>
<li><p>布隆过滤器:布隆过滤器是一种数据结构，对所有查询的参数以hash形式储存，再控制器先校验，不符合就丢弃，从而避免对底层存储系统的查询压力。</p>
<p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/9.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/9.png"></p>
</li>
<li><p>缓存空对象：当存储层没有被命中后，即使返回的空对象也将缓存起来，同时设置一个过期时间，之后再访问这个数据将从缓存中获取，保护后端数据源。</p>
<p> <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/10.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/10.png"></p>
</li>
</ol>
<p>但是这种方法存在两个问题：</p>
<p>1)如果空值被缓存起来，需要更多的空间。</p>
<p>1)即使设置了过期时间，还是会存在缓存层和储存层的数据会有一段时间窗口不一致，这对需要保持一致性的业务有影响。</p>
<h3 id="13-2-缓存击穿（查的量太大）"><a href="#13-2-缓存击穿（查的量太大）" class="headerlink" title="13.2.缓存击穿（查的量太大）"></a><strong>13.2.缓存击穿（查的量太大）</strong></h3><blockquote>
<p>概念：</p>
</blockquote>
<p>火力全部击中一个点，指一个key非常热点，在不停的抗者大并发，大并发集中对这一个点进行访问，当key在失效的瞬间，持续的大并发就穿破缓存，直接请求到数据库。如：微博热搜。如果在这个点没有抗住，就会宕机。</p>
<blockquote>
<p>解决方案：</p>
</blockquote>
<p>1)设置热点数据永不过期</p>
<p>2)加互斥锁-分布式锁：保证对每个key同时只有一个线程去查询服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发转移到了分布式锁，因此对分布式锁考验很大。JUC并发</p>
<h3 id="13-1-缓存雪崩"><a href="#13-1-缓存雪崩" class="headerlink" title="13.1.缓存雪崩"></a><strong>13.1.缓存雪崩</strong></h3><blockquote>
<p>概念：</p>
</blockquote>
<p>指在某一个时间段，缓存集体失效。或者redis宕机。</p>
<p>比如双十一时，把这波比较集中的商品放入缓存中，假设缓存1个小时，那么过了1小时后，对这批商品的访问，全部落到数据库上，对数据库来说产生周期性的压力波峰。储存层调用量增大，造成储存层挂掉的情况。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://github.com/peinimogu/learn-redis/raw/main/images/11.png" alt="https://github.com/peinimogu/learn-redis/raw/main/images/11.png"></p>
<p>如果集中过期，倒不是最致命的，最致命的缓存雪崩是缓存缓存服务器的某个节点宕机或断网。 例子：双十一时候停掉一些服务或服务降级，保证主要的服务可用，如退款。</p>
<blockquote>
<p>解决方案：</p>
</blockquote>
<p>1)redis高可用：这个思想的含义是，既然redis可能挂掉，那么我多增设几台redis，这样1台挂掉之后，其他的还可以工作，其实就是搭建的集群。</p>
<p>2)降流降级：思想是在缓存就失效后，通过枷锁或者队列来控制都数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>3)数据预热：在正式部署之前，对可能的数据预先访问一遍，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Amzpiper</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/amzpiper/2020/10/14/learn-redis/">https://github.com/amzpiper/2020/10/14/learn-redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/amzpiper" target="_blank">Amzpiper</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="/2020/10/14/learn-redis/Untitled.png" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/14/Java8%20Stream%EF%BC%9A2%E4%B8%87%E5%AD%9720%E4%B8%AA%E5%AE%9E%E4%BE%8B%EF%BC%8C%E7%8E%A9%E8%BD%AC%E9%9B%86%E5%90%88%E7%9A%84%E7%AD%9B%E9%80%89%E3%80%81%E5%BD%92%E7%BA%A6%E3%80%81%E5%88%86%E7%BB%84%E3%80%81%E8%81%9A%E5%90%88%208f8fb566f7f94c8c9d6fe53603b461e7/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshlcDdYLwybrjgMR9CvUtJxLfiaDrpVicXB9IRHibwib8ahP8StxILIwao9J1nG13d1E76ZNaB3domqiaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java8 Stream</div></div></a></div><div class="next-post pull-right"><a href="/2019/08/13/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2019/08/13/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/logo.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Maven学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://butterfly.js.org/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Amzpiper</div><div class="author-info__description">Amzpiper</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/amzpiper"><i class="fab fa-github"></i><span>关注我的GitHub</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#learn-redis"><span class="toc-number">1.</span> <span class="toc-text">learn-redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">1.基本命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.五大基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-String%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1.String类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-List%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.List类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Set-%E9%9B%86%E5%90%88"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3.Set(集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Hash-Map"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4.Hash~Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Zset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5.Zset(有序集合)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3.三种特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-geospatial%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1.geospatial地理位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Hyperloglog%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2.Hyperloglog基数统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Bitmaps-%E4%BD%8D%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3.Bitmaps 位存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.</span> <span class="toc-text">4.Redis的基本事务操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%9B%91%E6%8E%A7%EF%BC%81Watch%EF%BC%9ARedis%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">5.监控！Watch：Redis实现乐观锁、悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Jedis"><span class="toc-number">2.6.</span> <span class="toc-text">6.Jedis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-SpringBoot%E6%95%B4%E5%90%88"><span class="toc-number">2.7.</span> <span class="toc-text">7.SpringBoot整合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7"><span class="toc-number">3.</span> <span class="toc-text">高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Redis-conf%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">8.Redis.conf详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">9.Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-RDB-Redis-DataBase"><span class="toc-number">3.2.1.</span> <span class="toc-text">9.1.RDB (Redis DataBase)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-AOF-Append-Only-File"><span class="toc-number">3.2.2.</span> <span class="toc-text">9.2.AOF (Append Only File)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">3.3.</span> <span class="toc-text">10.Redis发布订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">11.Redis主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.5.</span> <span class="toc-text">12.哨兵模式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.6.</span> <span class="toc-text">13.Redis缓存穿透和雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%88%E6%9F%A5%E4%B8%8D%E5%88%B0%EF%BC%89"><span class="toc-number">3.6.1.</span> <span class="toc-text">13.1.缓存穿透（查不到）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E6%9F%A5%E7%9A%84%E9%87%8F%E5%A4%AA%E5%A4%A7%EF%BC%89"><span class="toc-number">3.6.2.</span> <span class="toc-text">13.2.缓存击穿（查的量太大）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.6.3.</span> <span class="toc-text">13.1.缓存雪崩</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/Dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Dubbo学习笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/08/13/Dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/logo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dubbo学习笔记"/></a><div class="content"><a class="title" href="/2021/08/13/Dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Dubbo学习笔记">Dubbo学习笔记</a><time datetime="2021-08-13T02:00:41.000Z" title="发表于 2021-08-13 10:00:41">2021-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/learn-elasticstack/" title="Elasticstack学习笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/08/13/learn-elasticstack/logo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Elasticstack学习笔记"/></a><div class="content"><a class="title" href="/2021/08/13/learn-elasticstack/" title="Elasticstack学习笔记">Elasticstack学习笔记</a><time datetime="2021-08-13T02:00:41.000Z" title="发表于 2021-08-13 10:00:41">2021-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/Spring%E7%AC%94%E8%AE%B0/" title="Spring笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://spring.io/images/spring-logo-9146a4d3298760c2e7e49595184e1975.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring笔记"/></a><div class="content"><a class="title" href="/2021/08/13/Spring%E7%AC%94%E8%AE%B0/" title="Spring笔记">Spring笔记</a><time datetime="2021-08-13T02:00:41.000Z" title="发表于 2021-08-13 10:00:41">2021-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/Mybatis%E7%AC%94%E8%AE%B0/" title="Mybatis笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://baomidou.com/img/logo.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis笔记"/></a><div class="content"><a class="title" href="/2021/08/13/Mybatis%E7%AC%94%E8%AE%B0/" title="Mybatis笔记">Mybatis笔记</a><time datetime="2021-08-13T02:00:41.000Z" title="发表于 2021-08-13 10:00:41">2021-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/Spring-MVC%E7%AC%94%E8%AE%B0/" title="Spring-MVC笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://spring.io/images/spring-logo-9146a4d3298760c2e7e49595184e1975.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring-MVC笔记"/></a><div class="content"><a class="title" href="/2021/08/13/Spring-MVC%E7%AC%94%E8%AE%B0/" title="Spring-MVC笔记">Spring-MVC笔记</a><time datetime="2021-08-13T02:00:41.000Z" title="发表于 2021-08-13 10:00:41">2021-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2021 By Amzpiper</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>